# Redis

## 为什么使用中间件
单体程序  ： 逻辑 + db 数据库
当用户数增加，并发量增大时，单机程序达到性能瓶颈， 需要进行水平扩展，拆分成多个节点。如Mysql 读写分离，对表进行横向和纵向的拆分。
客户端与服务器之间对应关系 session, 记录在中间件中，这是中间件出现的最初根源。
常用的中间件分为两类，缓存和消息队列。

* 随着业务规模扩大，单体应用不再满足业务场景需求
* 用户数量剧增，单凭数据库无法扛住并发压力
* 业务场景复杂需要解耦
* 业务场景丰富造成访问热点

对于静态资源，可能需要将资源保存在内存中，缓存的需求。  
订阅发布模式，消息队列，用来进行解耦  
CDN

### 缓存
缓存的分类：  
* 本地缓存
* 分布式缓存

数据请求，一般分为三层，首先在应用程序本身的缓存中查找， 如Django 自身的缓存。如果没有，向后端的分布式缓存请求，如redis, memcached 等。如果还没有，就到数据库中找。

### 缓存的应用场景
本地缓存用来保存静态资源，配置等。分布式缓存用来存储全局资源，多个业务之间进行共享的。

## 缓存的同步方式
缓存和数据库之间的数据同步方式：
* Cache Aside : 读取缓存，如果缓存中有，返回给用户。如果缓存中没有，从数据库中读取，返回给用户的同时，在缓存中保存。
当用户更新数据时，更新数据库，并清除缓存。
Cache Aside 方式，逻辑简单，缺点是对业务代码有侵入，自己维护数据的读取更新缓存的策略，
* Read Write Through: 缓存+数据库，对于后端是一个整体，
* Write Back: 不考虑数据库，认为只有缓存.指修改缓存，不管数据库，当缓存内容被更新，会通过消息队列通知同步数据到数据库。
  优点，速度快，不用等数据库操作。缺点是可能会出现数据丢失的风险

从数据库角度看缓存：
* 双写方式：应用程序会将数据在缓存和数据库中分别写入数据。 有点：实现简单，缺点：容易产生数据不一致，比如写缓存成功，但写数据库失败。所以一般以数据库为准，先写数据库再写缓存。 引入分布式事务，当写缓存失败后，会定期从数据库中更新缓存数据
* 消息队列方式： 当用户并发请求量很大，如果后台程序直接写数据库，数据库可能扛不住，所以让后台应用程序先写消息队列，然后由中间件写入数据库。消息队列也需要保证可靠性
* MySQL Binlog: MySQL 主从配置，使用binlog， 通过binlog回放写入缓存中。这种方式是最可靠的，但性能较差。binlog 是线性处理的，可能会造成数据库阻塞

这几种方式都会产生数据不一致，写入速度 递减；耦合度：递减；复杂的：递增

## 缓存有可能出现的问题
引入缓存后，提高了系统的并发能力，但也带来了其他问题：
* 缓存穿透  
    使用缓存的目的是缓解数据库的压力，但当请求不存在的数据时，就会直接请求到数据库，如果量比较大或遭到攻击，压力会再次落到数据库上。 解决方案： 对返回值时空值的请求，也进行缓存， 缓存时间建议要短一些。 或者使用布隆过滤器
* 缓存并发  
    当某一个key刚刚过期，然后有大量的请求过来，此时这些请求又落到数据库上，如果请求量很大，可能会压垮数据库。解决方案： 使用互斥锁，如 Redis 中SETNX ,第一个请求加锁，从数据库中更新，第二个请求无法获取锁，阻塞。
* 缓存雪崩  
    如果出现同一时刻加入了大量的key ，经过一段时间后这些key会同时过期，请求会落到数据库上。 解决方法： 在加入缓存时， 缓存时间会加上一个随机值，避免同时失效。还可以使用多级缓存的方案，但是同时会增加难度

## Redis 使用

redis 字符串编码  int, embstr, row.  int 是8字节长度， embstr 小于39字节长度， raw 大于39 字节长度， 根据长度，会自动进行转换  
scl enable devtoolset-8 bash  

通过指定配置文件，来修改配置，如bind, protected-mode  
关闭redis-server : 使用redis-cli 连接服务，密码验证通过后， shutdown  

使用Python 连接 redis  
```
import redis
client = redis.Redis(host='10.0.110.34')
print (client.keys())
for key in client.keys():
    print(key.decode())
```
通过decode 将bytes 转成 python 的字符串
在生产环境，不要使用keys  

### redis string

SETNX key value   client.set('key', 'value', nx=True)  
APPEND key value  client.append('key', 'value')  
...  

### redis list

### redis set

### redis sorted set

